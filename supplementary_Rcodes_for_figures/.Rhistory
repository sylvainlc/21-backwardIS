setwd("~/Documents/particle_smoothing_for_SDE/21-backwardIS/supplementary_Rcodes_for_figures")
my_theme <- function(base_size = 8){
theme_bw()  %+replace%
theme(
panel.border = element_rect(colour = "black",
fill = rgb(0, 0, 0, 0)),
# plot.background = element_rect(fill = "white"),# bg around panel
legend.background = element_blank(),
text = element_text(family = "LM Roman 10", size = base_size),
axis.title = element_text(size = rel(1)),
legend.text = element_text(size = rel(1)),
legend.title = element_text(size = rel(1)),
axis.text = element_text(size = rel(1)),
strip.background = element_rect(fill = "lightgoldenrod1",
color = "black"),
plot.subtitle = element_text(hjust = 0.5, size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0.5))
}
theme_set(my_theme(base_size = 14))
rm(list = ls())
library(GrandParisPackage)
library(parallel) # For parallel computing (do not work on windows)
library(tidyverse) # For data processing
library(tictoc) # For time comparisons
my_seed <- 333 # For all experiments, the random seed
set.seed(my_seed) # For reproducibility
trueTheta <- pi / 4; trueSigma2 <- 1;
n <- 11; times <- seq(from = 0, to = 5, length = n);
SINEprocess <- SINE_simulate(theta = trueTheta, sigma2 = trueSigma2,
x0 = 10, times = times)
observations <- SINEprocess[, "observations"]
rm(list = ls())
library(GrandParisPackage)
library(tidyverse)
library(parallel)
# True parameters
trueTheta <- pi/4; trueSigma2 <- 1;
n <- 5000; times <- seq(0, by = 1, length = n)
# The following code creates 500 trajectories in a directory "simulated_data"
# that can be created with the following code
# dir.create("simulated_data")
n_traj <- 500
# For windows user, replace by lapply and remove the mc.cores argument below
mclapply(1:n_traj,
function(i){
seed <- 100 + i
set.seed(seed)
simulated_POD <- SINE_simulate(theta = trueTheta,
sigma = trueSigma2, x0 = 0,
times = times)
write.table(simulated_POD, paste0("simulated_data/simul_data_seed", seed, ".txt"),
col.names = T, row.names = F, sep = ";")
},
mc.cores= detectCores())
# For windows user, replace by lapply and remove the mc.cores argument below
mclapply(1:n_traj,
function(i){
seed <- 100 + i
set.seed(seed)
simulated_POD <- SINE_simulate(theta = trueTheta,
sigma = trueSigma2, x0 = 0,
times = times)
write.table(simulated_POD, paste0("simulated_data/simul_data_seed", seed, ".txt"),
col.names = T, row.names = F, sep = ";")
},
mc.cores= 1)
ls()
getwd()
dir()
dir.create("simulated_data")
# The following code creates 500 trajectories in a directory "simulated_data"
# that can be created with the following code
# dir.create("simulated_data")
n_traj <- 500
# For windows user, replace by lapply and remove the mc.cores argument below
mclapply(1:n_traj,
function(i){
seed <- 100 + i
set.seed(seed)
simulated_POD <- SINE_simulate(theta = trueTheta,
sigma = trueSigma2, x0 = 0,
times = times)
write.table(simulated_POD, paste0("simulated_data/simul_data_seed", seed, ".txt"),
col.names = T, row.names = F, sep = ";")
},
mc.cores= detectCores())
# Get the appropriate trajectory
seed <- 122
set.seed(seed) # For reproducibility
simulated_POD <- read.table(paste0("simulated_data/simul_data_seed", seed, ".txt"),
sep = ";", header = T)
observations <- simulated_POD[, "observations"]
# Get the appropriate trajectory
seed <- 122
set.seed(seed) # For reproducibility
simulated_POD <- read.table(paste0("simulated_data/simul_data_seed", seed, ".txt"),
sep = ";", header = T)
simulated_POD <- read.table(paste0("simulated_data/simul_data_seed", seed, ".txt"),
sep = ";", header = TRUE)
observations <- simulated_POD[, "observations"]
get_estimation_one_obs_several_start <- function(){
gradientSteps <- get_grad_steps(0.6, cst = 8)
n_start_points <- 50
n_particles <- 100
N_tilde <- n_particles / 10
allRes <- mclapply(1:n_start_points, function(seed){
set.seed(seed)
thetaStart <- runif(1, 0, 2 * pi)
fastTangOR(observations, times, particleSize = n_particles,
thetaModel = thetaStart, sigma2 = trueSigma2,
updateOrders = rep(TRUE, n),
gradientSteps = gradientSteps,
all = FALSE, estimateTheta = TRUE, estimateSigma2 = FALSE,
randomWalkParam = 1, backwardSampleSize = N_tilde, IS = TRUE)
},
mc.cores = detectCores() - 1)
thetaEst <- sapply(allRes, function(x) x$Estimates[,1]) %% (2*pi)
out_path <- paste0("simulation_results/est_oneObs_severalStarts_",
ifelse(IS, "IS", "AR"), ".txt")
write.table(thetaEst, file = out_path, col.names = F,
row.names = F, sep = ";")
return(NULL)
}
get_estimation_one_obs_several_start()
get_grad_steps <- function(gradient_power, cst = 8){
firstStep <- 0.5
nStart <- 300
steps <- c(rep(firstStep, nStart), sapply(cst * firstStep * (1:(n - nStart) )^(-gradient_power),
function(x) min(x, firstStep)))
matrix(steps , ncol = 2, nrow = n)
}
gradientSteps <- get_grad_steps(0.6, cst = 8)
n_start_points <- 50
n_particles <- 100
N_tilde <- n_particles / 10
allRes <- mclapply(1:n_start_points, function(seed){
set.seed(seed)
thetaStart <- runif(1, 0, 2 * pi)
fastTangOR(observations, times, particleSize = n_particles,
thetaModel = thetaStart, sigma2 = trueSigma2,
updateOrders = rep(TRUE, n),
gradientSteps = gradientSteps,
all = FALSE, estimateTheta = TRUE, estimateSigma2 = FALSE,
randomWalkParam = 1, backwardSampleSize = N_tilde, IS = TRUE)
},
mc.cores = detectCores() - 1)
devtools::install_github("papayoun/LotkaVoltR")
rm(list = ls()) # Cleaning environment
library(LotkaVoltR) # Dedicated library
library(tidyverse) # For data processing
a1 <- c(12, 0.05, 1) # Prey parameters
a2 <- c(2, 0.2, 0.1) # Predator parameters
Gamma <- matrix(c(0.5, 0.1, 0.1, 0.2), nrow = 2) # Diffusion parameters
mu0 <- c(50,20) # Mean of the inital distribution
Sigma0 <- diag(1, 2) # Variance of the initial distribution
Sigma_obs <- matrix(c(0.01, 0.005, 0.005, 0.01), ncol = 2) # Observation noise
q_values <- c(0.2, 0.3) # Known q values
# Creation of a Partially Observed Lotka Volterra model
POLV_model <- POLV_create(a1 = a1, a2 = a2, gam = Gamma, mu0 = mu0,
sigma0 = Sigma0, cov = Sigma_obs, qs = q_values)
simulation_times <- seq(from = 0, by = 1e-6, # Simulation time step, small!!
length.out = 3*10^6 + 1)
selection <- seq(1, length(simulation_times), length.out = 301)
set.seed(333)
simulated_process <- POLV_simulate(POLV_model,
times = simulation_times,
selection = selection)
observation_times <- simulation_times[selection]
observations <- simulated_process[, c("Y1", "Y2")]
parameters_list <- list(a1 = a1, a2 = a2, mu0 = mu0,
sigma0 = Sigma0,
RWC = diag(0.005, 2), # Parameter for the particle filter
qs = q_values, cov = Sigma_obs,
wD = 1, wO = 1,
gam = Gamma)
particle_filter <- PF_create(parameters_list, t(observations),
observation_times, 2e2,
n_euler_skel = 30)
smoothing_exp <- particle_filter$runSmoothing()
devtools::install_github("papayoun/LotkaVoltR")
rm(list = ls()) # Cleaning environment
library(LotkaVoltR) # Dedicated library
library(tidyverse) # For data processing
a1 <- c(12, 0.05, 1) # Prey parameters
a2 <- c(2, 0.2, 0.1) # Predator parameters
Gamma <- matrix(c(0.5, 0.1, 0.1, 0.2), nrow = 2) # Diffusion parameters
mu0 <- c(50,20) # Mean of the inital distribution
Sigma0 <- diag(1, 2) # Variance of the initial distribution
Sigma_obs <- matrix(c(0.01, 0.005, 0.005, 0.01), ncol = 2) # Observation noise
q_values <- c(0.2, 0.3) # Known q values
# Creation of a Partially Observed Lotka Volterra model
POLV_model <- POLV_create(a1 = a1, a2 = a2, gam = Gamma, mu0 = mu0,
sigma0 = Sigma0, cov = Sigma_obs, qs = q_values)
simulation_times <- seq(from = 0, by = 1e-6, # Simulation time step, small!!
length.out = 3*10^6 + 1)
selection <- seq(1, length(simulation_times), length.out = 301)
set.seed(333)
simulated_process <- POLV_simulate(POLV_model,
times = simulation_times,
selection = selection)
observation_times <- simulation_times[selection]
observations <- simulated_process[, c("Y1", "Y2")]
parameters_list <- list(a1 = a1, a2 = a2, mu0 = mu0,
sigma0 = Sigma0,
RWC = diag(0.005, 2), # Parameter for the particle filter
qs = q_values, cov = Sigma_obs,
wD = 1, wO = 1,
gam = Gamma)
particle_filter <- PF_create(parameters_list, t(observations),
observation_times, 2e2,
n_euler_skel = 30)
smoothing_exp <- particle_filter$runSmoothing()
